"""===========================================================================================================================================================================Title:        ZEN-GARDENCreated:      October-2021Authors:      Alissa Ganter (aganter@ethz.ch)Organization: Laboratory of Risk and Reliability Engineering, ETH ZurichDescription:  Class is defining the postprocessing of the results.              The class takes as inputs the optimization problem (model) and the system configurations (system).              The class contains methods to read the results and save them in a result dictionary (rawResultDict).==========================================================================================================================================================================="""import osimport pickleimport pandas as pdfrom datetime import datetimeimport data.config as configimport matplotlib.pyplot as pltimport numpy as npclass Postprocess:    def __init__(self):        """postprocessing of the results of the optimization"""        self.system = config.system        self.analysis = config.analysis        self.rawResultDict = {}        self.years = list(range(0,self.system["timeStepsYearly"]))        self.useGreenfield = True        if self.useGreenfield:            self.extraString = "_gf"        else:            self.extraString = ""        # self.years = [0,1,2,3]        # self.prepare    = Prepare(config)        today           = datetime.today()        self.filename   = "resultsmodel_" + today.strftime("%Y-%m-%d")        self.loadPFResults()        self.loadMFResults()        # calculate costs        self.resultDict = {}        self.calculateCosts()        self.calculateCapacities()        # plot        self.plotCosts()        self.plotCapacities()        plt.show()        a=1    def loadPFResults(self):        fullFilename = self.filename + "_perfectForesight"        self.rawResultDict["PF"] = self.loadResult(fullFilename)    def loadMFResults(self):        fullFilename = self.filename + "_rollingHorizon"        self.rawResultDict["MF"] = {}        if self.useGreenfield:            MFFolders = [folder for folder in os.listdir() if fullFilename in folder and "gf" in folder]        else:            MFFolders = [folder for folder in os.listdir() if fullFilename in folder and "gf" not in folder]        for idx,folder in enumerate(MFFolders):            self.rawResultDict["MF"][idx] = self.loadResult(folder)    def loadResult(self,filename):        with open(filename + "/vars/varDict.pickle", "rb") as inputFile:            varDict = pickle.load(inputFile)        with open(filename + "/params/paramDict.pickle", "rb") as inputFile:            paramDict = pickle.load(inputFile)        rawResultDict = {"varDict":varDict,"paramDict":paramDict}        return  rawResultDict    def calculateCosts(self):        # PF        _costsPF = pd.DataFrame(index=["capexTotal","opexTotal","costCarrierTotal","costTotal"],columns=self.years)        for row in _costsPF.index:            _costsPF.loc[row] = self.rawResultDict["PF"]["varDict"][row]        _costsPF["Total"] = _costsPF.sum(axis=1)        # MF        _costsMF = pd.DataFrame(index=["capexTotal", "opexTotal", "costCarrierTotal", "costTotal"],                                columns=self.years)        for row in _costsMF.index:            for column in _costsMF.columns:                _costsMF.loc[row,column] = self.rawResultDict["MF"][column]["varDict"][row][column]        _costsMF["Total"] = _costsMF.sum(axis=1)        self.resultDict["costs"] = {"PF":_costsPF,"MF":_costsMF}    def calculateCapacities(self):        # PF        _capacityPF = pd.DataFrame(index=pd.MultiIndex.from_product([self.system["setConversionTechnologies"]+self.system["setStorageTechnologies"],self.system["setNodes"]],names=["tech","node"]),                                columns=self.years)        for row in _capacityPF.index:            for column in _capacityPF.columns:                if row+(column,) in self.rawResultDict["PF"]["varDict"]["capacity"]:                    _capacityPF.loc[row,column] = self.rawResultDict["PF"]["varDict"]["capacity"][row+(column,)]        _capacityPF = _capacityPF.fillna(0)        _capacityPF = _capacityPF.groupby("tech").sum()        # MF        _capacityMF = pd.DataFrame(index=pd.MultiIndex.from_product([self.system["setConversionTechnologies"]+self.system["setStorageTechnologies"],self.system["setNodes"]],names=["tech","node"]),                                columns=self.years)        for row in _capacityMF.index:            for column in _capacityMF.columns:                if row + (column,) in self.rawResultDict["MF"][column]["varDict"]["capacity"]:                    _capacityMF.loc[row, column] = self.rawResultDict["MF"][column]["varDict"]["capacity"][row+(column,)]        _capacityMF = _capacityMF.fillna(0)        _capacityMF = _capacityMF.groupby("tech").sum()        self.resultDict["capacity"] = {"PF": _capacityPF, "MF": _capacityMF}    def plotCosts(self):        maxVal = max(self.resultDict["costs"]["PF"][self.years].max().max(),                     self.resultDict["costs"]["MF"][self.years].max().max())        maxVal = 1e4 * np.ceil(maxVal / 1e4)        # PF        plt.figure()        self.resultDict["costs"]["PF"][self.years].T.plot()        plt.legend(loc = "upper left")        plt.xlabel("Optimization Years")        plt.ylabel("Costs [10^6 Euro]")        plt.title("Costs - Perfect Foresight")        plt.xticks(self.years)        plt.ylim([0, maxVal])        plt.xlim([self.years[0],self.years[-1]])        plt.savefig(f"costs_PF{self.extraString}.svg", format="svg")        # MF        plt.figure()        self.resultDict["costs"]["MF"][self.years].T.plot()        plt.legend(loc = "upper left")        plt.xlabel("Optimization Years")        plt.ylabel("Costs [10^6 Euro]")        plt.title("Costs - Myopic Foresight")        plt.xticks(self.years)        plt.ylim([0, maxVal])        plt.xlim([self.years[0], self.years[-1]])        plt.savefig(f"costs_MF{self.extraString}.svg", format="svg")    def plotCapacities(self):        maxVal = max(self.resultDict["capacity"]["PF"][self.years].sum(axis=0).max().max(),                     self.resultDict["capacity"]["MF"][self.years].sum(axis=0).max().max())        maxVal = 100*np.ceil(maxVal/100)        # PF        plt.figure()        self.resultDict["capacity"]["PF"][self.years].T.plot.area(lw = 0)        plt.legend(loc = "upper left")        plt.xlabel("Optimization Years")        plt.ylabel("Capacities [GW]/[GWh]")        plt.title("Capacities - Perfect Foresight")        plt.xticks(self.years)        plt.ylim([0,maxVal])        plt.xlim([self.years[0], self.years[-1]])        plt.savefig(f"capacity_PF{self.extraString}.svg", format = "svg")        # MF        plt.figure()        self.resultDict["capacity"]["MF"][self.years].T.plot.area(lw = 0)        plt.legend(loc = "upper left")        plt.xlabel("Optimization Years")        plt.ylabel("Capacities [GW]/[GWh]")        plt.title("Capacities - Myopic Foresight")        plt.xticks(self.years)        plt.ylim([0, maxVal])        plt.xlim([self.years[0], self.years[-1]])        plt.savefig(f"capacity_MF{self.extraString}.svg", format="svg")if __name__ == "__main__":    evaluation = Postprocess()