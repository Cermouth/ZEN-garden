"""===========================================================================================================================================================================Title:        ZEN-GARDENCreated:      October-2021Authors:      Alissa Ganter (aganter@ethz.ch)Organization: Laboratory of Risk and Reliability Engineering, ETH ZurichDescription:  Class is defining the postprocessing of the results.              The class takes as inputs the optimization problem (model) and the system configurations (system).              The class contains methods to read the results and save them in a result dictionary (rawResultDict).==========================================================================================================================================================================="""import osimport pickleimport pandas as pdfrom datetime import datetimeimport data.config as configimport matplotlib.pyplot as pltimport numpy as npfrom model.objects.energy_system import EnergySystemclass Postprocess:    def __init__(self):        """postprocessing of the results of the optimization"""        self.system = config.system        self.analysis = config.analysis        self.rawResultDict = {}        self.years = list(range(0,self.system["timeStepsYearly"]))        self.useGreenfield = False        if self.useGreenfield:            self.extraString = "_gf"        else:            self.extraString = ""        # self.years = [0,1,2,3]        # self.prepare    = Prepare(config)        today           = datetime.today()        datestring      = today.strftime("%Y-%m-%d")        # datestring      = "2022-03-29"        self.filename   = "resultsmodel_" + datestring        self.loadPFResults()        self.loadMFResults()        # calculate costs        self.resultDict = {}        self.calculateCosts()        self.calculateCapacities()        self.calculateOperation()        # plot        self.plotCosts()        self.plotCapacities()        plt.show()        a=1    def loadPFResults(self):        fullFilename = self.filename + "_perfectForesight" + self.extraString        self.rawResultDict["PF"] = self.loadResult(fullFilename)        try:            with open(fullFilename + "/dictAllOrderTimeSteps.pickle", "rb") as inputFile:                orderTimeSteps = pickle.load(inputFile)            self.rawResultDict["PF"]["orderTimeSteps"] = orderTimeSteps        except:            pass    def loadMFResults(self):        fullFilename = self.filename + "_rollingHorizon"        self.rawResultDict["MF"] = {}        if self.useGreenfield:            MFFolders = [folder for folder in os.listdir() if fullFilename in folder and "gf" in folder]        else:            MFFolders = [folder for folder in os.listdir() if fullFilename in folder and "gf" not in folder]        for idx,folder in enumerate(MFFolders):            self.rawResultDict["MF"][idx] = self.loadResult(folder)        try:            with open(folder + "/dictAllOrderTimeSteps.pickle", "rb") as inputFile:                orderTimeSteps = pickle.load(inputFile)            self.rawResultDict["MF"]["orderTimeSteps"] = orderTimeSteps        except:            pass    def loadResult(self,filename):        with open(filename + "/vars/varDict.pickle", "rb") as inputFile:            varDict = pickle.load(inputFile)        with open(filename + "/params/paramDict.pickle", "rb") as inputFile:            paramDict = pickle.load(inputFile)        rawResultDict = {"varDict":varDict,"paramDict":paramDict}        return  rawResultDict    def calculateCosts(self):        # PF        _costsPF = pd.DataFrame(index=["capexTotal","opexTotal","costCarrierTotal","costTotal"],columns=self.years)        for row in _costsPF.index:            _costsPF.loc[row] = self.rawResultDict["PF"]["varDict"][row]        _costsPF["Total"] = _costsPF.sum(axis=1)        # MF        _costsMF = pd.DataFrame(index=["capexTotal", "opexTotal", "costCarrierTotal", "costTotal"],                                columns=self.years)        for row in _costsMF.index:            for column in _costsMF.columns:                _costsMF.loc[row,column] = self.rawResultDict["MF"][column]["varDict"][row][column]        _costsMF["Total"] = _costsMF.sum(axis=1)        self.resultDict["costs"] = {"PF":_costsPF,"MF":_costsMF}    def calculateCapacities(self):        # PF        _capacityPF = pd.DataFrame(index=pd.MultiIndex.from_product([self.system["setConversionTechnologies"]+self.system["setStorageTechnologies"],self.system["setNodes"]],names=["tech","node"]),                                columns=self.years)        for row in _capacityPF.index:            for column in _capacityPF.columns:                if row+(column,) in self.rawResultDict["PF"]["varDict"]["capacity"]:                    _capacityPF.loc[row,column] = self.rawResultDict["PF"]["varDict"]["capacity"][row+(column,)]        _capacityPF = _capacityPF.fillna(0)        _capacityPF = _capacityPF.groupby("tech").sum()        # MF        _capacityMF = pd.DataFrame(index=pd.MultiIndex.from_product([self.system["setConversionTechnologies"]+self.system["setStorageTechnologies"],self.system["setNodes"]],names=["tech","node"]),                                columns=self.years)        for row in _capacityMF.index:            for column in _capacityMF.columns:                if row + (column,) in self.rawResultDict["MF"][column]["varDict"]["capacity"]:                    _capacityMF.loc[row, column] = self.rawResultDict["MF"][column]["varDict"]["capacity"][row+(column,)]        _capacityMF = _capacityMF.fillna(0)        _capacityMF = _capacityMF.groupby("tech").sum()        self.resultDict["capacity"] = {"PF": _capacityPF, "MF": _capacityMF}    def calculateOperation(self):        EnergySystem.setOrderTimeStepsDict(self.rawResultDict["PF"]["orderTimeSteps"])        _rawOutputFlowPF    = pd.Series(self.rawResultDict["PF"]["paramDict"]["maxLoad"],name="maxLoad")        _rawOutputFlowPF    = _rawOutputFlowPF.to_frame()        duration            = self.rawResultDict["PF"]["paramDict"]["timeStepsOperationDuration"]        outputFlow          = pd.Series(self.rawResultDict["PF"]["varDict"]["outputFlow"]).loc[slice(None),"electricity"]        inputFlow           = pd.Series(self.rawResultDict["PF"]["varDict"]["inputFlow"])        inputFlow.index     = inputFlow.index.droplevel(1)        capacity            = self.rawResultDict["PF"]["varDict"]["capacity"]        # _rawOutputFlowPF["duration"]    = _rawOutputFlowPF.apply(lambda row: duration[row.name[0],row.name[2]],axis=1)        _rawOutputFlowPF["outputFlow"]  = _rawOutputFlowPF.apply(lambda row: outputFlow[row.name] if row.name in outputFlow else 0,axis=1)        _rawOutputFlowPF["inputFlow"]   = _rawOutputFlowPF.apply(            lambda row: inputFlow[row.name] if row.name in inputFlow else 0, axis=1)        _rawOutputFlowPF["year"]        = _rawOutputFlowPF.apply(            lambda row: EnergySystem.encodeTimeStep(None,EnergySystem.decodeTimeStep(row.name[0],row.name[2]),"yearly"), axis=1)        _rawOutputFlowPF["capacity"]    = _rawOutputFlowPF.apply(            lambda row: capacity[row.name[0:2]+(row["year"],)] if row.name[0:2]+(row["year"],) in capacity else 0,axis=1)        _rawOutputFlowPF["usableCapacity"]  = _rawOutputFlowPF["capacity"]*_rawOutputFlowPF["maxLoad"]        _rawOutputFlowPF["usedCapacity"]    = _rawOutputFlowPF["outputFlow"]/_rawOutputFlowPF["capacity"]        _rawOutputFlowPF["usedUsableCapacity"] = _rawOutputFlowPF["outputFlow"] / _rawOutputFlowPF["usableCapacity"]        self.resultDict["outputFlow"] = {"PF":_rawOutputFlowPF}        a=1        a=1    def plotCosts(self):        maxVal = max(self.resultDict["costs"]["PF"][self.years].max().max(),                     self.resultDict["costs"]["MF"][self.years].max().max())        maxVal = 1e4 * np.ceil(maxVal / 1e4)        # PF        plt.figure()        self.resultDict["costs"]["PF"][self.years].T.plot()        plt.legend(loc = "upper left")        plt.xlabel("Optimization Years")        plt.ylabel("Costs [10^6 Euro]")        plt.title("Costs - Perfect Foresight")        plt.xticks(self.years)        plt.ylim([0, maxVal])        plt.xlim([self.years[0],self.years[-1]])        plt.savefig(f"costs_PF{self.extraString}.svg", format="svg")        # MF        plt.figure()        self.resultDict["costs"]["MF"][self.years].T.plot()        plt.legend(loc = "upper left")        plt.xlabel("Optimization Years")        plt.ylabel("Costs [10^6 Euro]")        plt.title("Costs - Myopic Foresight")        plt.xticks(self.years)        plt.ylim([0, maxVal])        plt.xlim([self.years[0], self.years[-1]])        plt.savefig(f"costs_MF{self.extraString}.svg", format="svg")    def plotCapacities(self):        maxVal = max(self.resultDict["capacity"]["PF"][self.years].sum(axis=0).max().max(),                     self.resultDict["capacity"]["MF"][self.years].sum(axis=0).max().max())        maxVal = 100*np.ceil(maxVal/100)        # PF        plt.figure()        self.resultDict["capacity"]["PF"][self.years].T.plot.bar(stacked=True)        plt.legend(loc = "upper left")        plt.xlabel("Optimization Years")        plt.ylabel("Capacities [GW]/[GWh]")        plt.title("Capacities - Perfect Foresight")        plt.xticks(self.years)        plt.ylim([0,maxVal])        # plt.xlim([self.years[0], self.years[-1]])        plt.savefig(f"capacity_PF{self.extraString}.svg", format = "svg")        # MF        plt.figure()        self.resultDict["capacity"]["MF"][self.years].T.plot.bar(stacked=True)        plt.legend(loc = "upper left")        plt.xlabel("Optimization Years")        plt.ylabel("Capacities [GW]/[GWh]")        plt.title("Capacities - Myopic Foresight")        plt.xticks(self.years)        plt.ylim([0, maxVal])        # plt.xlim([self.years[0], self.years[-1]])        plt.savefig(f"capacity_MF{self.extraString}.svg", format="svg")if __name__ == "__main__":    evaluation = Postprocess()